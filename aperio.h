// ****************************************************************************
// Aperio
// ----------------------------------------------------------------------------
// Main QT window file, contains interactive events and main code
// Header file contains slots, (functions called in response to signals, such
// as clicking on a button on the QT form)
//
// ****************************************************************************

#ifndef APERIO_H
#define APERIO_H

#include <QtWidgets/QMainWindow>
#include "ui_aperio.h"

// Forward declarations (pimpl)
class MyInteractorStyle;
class vtkMyShaderPass;
class vtkMyDepthPeelingPass;

// Custom
#include "Utility.h"
#include "vtkMyShaderPass.h"
#include "vtkMyPrePass.h"
#include "CarveConnector.h"
#include "MySuperquadricSource.h"

// QT Includes
#include <QMessageBox>
#include <QColorDialog>

// VTK Includes
#include <vtk/QVTKWidget.h>
#include <vtk/vtkPlaneSource.h>
#include <vtk/vtkSplineWidget2.h>

//--------------------- Custom Entity Classes ----------------------------
class MyPoint
{
public:
	MyPoint() {}
	~MyPoint() {}

	vtkVector3f point;
	vtkVector3f normal;
};

// Tool types
typedef enum { CUTTER, KNIFE, ROD, RING, HINGE } ToolType;



///-------------------------------------------------------------------------------------------
/// <summary> MyElem, represents a Superquadric element - item inside elems vector (endpoints, avgnormal, actor, cellLocator etc.)
/// </summary>
class MyElem
{
public:
	MyElem() {}
	~MyElem() {}

	ToolType toolType = CUTTER;

	MyPoint p1;
	MyPoint p2;
	vtkVector3f scale;

	vtkVector3f right;
	vtkVector3f up;
	vtkVector3f forward;
	float spinAngle;
	float spinFlipped;
	float tilt;

	bool  ribbons		= false;
	bool  frontRibbons	= true;
	float ribbonWidth	= 0.2;
	int   ribbonFrequency = 4;
	float ribbonTilt	= 0.1;

	bool inverse; 
	 
	vtkSmartPointer<vtkActor> actor;								// Superquadric actor
	vtkSmartPointer<vtkActor> outline;								// Superquadric actor
	vtkSmartPointer<MySuperquadricSource> source;					// the superquadric source
	vtkSmartPointer<vtkTransformPolyDataFilter> transformFilter;	// the transform filter

	vtkSmartPointer<vtkPlaneSource> planeSource;					// used to pick on when positioning elem in world
	vtkSmartPointer<vtkActor> planeActor;

	/// <summary> Superquad Path (on phi = 0) </summary>
	vtkSmartPointer<vtkPolyData> path;
	vtkSmartPointer<vtkActor> pathActor;

	/// <summary> Elem's CellLocator? (do we need it?) For speeding up raycast/picking (BuildLocator must be called with new Widget)_</summary>
	vtkSmartPointer<vtkCellLocator> cellLocator;

	vtkVector3f avgnormal;	// Average normals of sampled points?
};

///---------------------------------------------------------------------------------------------
/// <summary> CustomMesh, represents a mesh read-in from file - item inside meshes vector (opacity, name, actor, etc.)
/// </summary>
class CustomMesh
{
public:
	/// <summary> Mesh's opacity </summary>
	float opacity;
	/// <summary> Mesh's name (group name) </summary>
	string name;
	/// <summary> Mesh's color </summary>
	vtkColor3f color;
	/// <summary> Mesh's actor, contains Mapper->GetOutput() - vtkPolyData </summary>
	vtkSmartPointer<vtkActor> actor;
	/// <summary> Mesh's CellLocator, Important for speeding up raycast/picking (BuildLocator must be called with new CustomMesh)_</summary>
	vtkSmartPointer<vtkCellLocator> cellLocator;

	// Mesh's dimensions
	double size[3];
	double center[3];

	// Whether or not it is a generated mesh (cut piece) or original piece
	bool generated;
	
	// Generated piece properties:
	vtkVector3f snormal;	// Superquadric normal
	vtkVector3f sforward;		// Superquadric up vector
	vtkVector3f hingePivot; // Superquadric initial position is hinge
	
	vtkVector3f path_initpt_exact;
	int path_id;		// Sort by this (index in path polydata for closest intersection point)

	int path_pt;		// Current point on path (index)
	float path_angle = 0;
	float path_leafangle = 0;
	//vtkSmartPointer<vtkPolyData> path;	// Path mesh is connected to
	ToolType pathType = RING;

	float hingeAngle;
	float hingeAmount;

	vtkVector3f cornerOBB, axesOBB[3], sizeOBB;
	vtkSmartPointer<vtkActor> actorOBB;

	// Reference to element
	weak_ptr<MyElem> elem;

	// index into custom mesh array. 
	// If != nullptr then this mesh must be a child mesh generated by Carve
	weak_ptr<CustomMesh> parentMesh;

	vtkVector3f lastBitangent;

	// Custom properties
	bool selected;
};

class CustomTexture
{
public:
	~CustomTexture()
	{
		glDeleteTextures(1, &name);
	}
	vtkSmartPointer<vtkTexture> texture;
	unsigned char *pointer;
	int width;
	int height;
	GLuint name = 0;
	int unit = 8;	// 20

	bool alreadygenerated = false;
};

// ----------------------------------------------------------------------------------------
/// <summary> Main window class
/// </summary>
class aperio : public QMainWindow
{
	Q_OBJECT
		
public:
	aperio(QWidget *parent = 0);
	~aperio();

#pragma region ~~UNIFORMS

	// public access variables (mostly in shader as uniforms)
	double mouse[3];				// Put in struct later	- on mouse move updated
	double mouseNorm[3];			// GL_COLOR_ATTACHMENT0Put in struct later - on mouse move updated
	
	bool wiggle;
	float mouseSize;				// Recompute from bounds
	float brushDivide;				// division factor for mouseSize
	float brushSize;
	bool previewer = true;
	bool cap = true;
	int shadingnum;					// current shader (toon, phong, etc)

	float selectedColor[3];

	float pos1[3];					// position of superquad (pt1 and pt2)
	float pos2[3];

	float norm1[3];					// normal of superquad (pt1 and pt2)
	float norm2[3];

	bool difftrans;
	int shininess;
	float darkness;

	float wavetime;

#pragma endregion

#pragma region ~~VARIABLES

	// Public variables
	vtkSmartPointer<vtkSplineWidget2> splineWidget;

	vtkSmartPointer<vtkMyPrePass> preP;
	vtkSmartPointer<vtkMyShaderPass> mainP;

	CustomTexture matcap;	

	bool inverseTrigger = false;

	bool realtimeupdate = false;

	float roundnessScale = 100.0;	// Superquadric roundness (divider)
	float thicknessScale = 100.0;	// Superquadric roundness (divider) out of 1

	// QT Window variables (preview and original size of window)
	QRect _orig_size;
	bool preview;
	bool glew_available;

	bool snapToBBOX = false;
	bool snapToBBOXReal = false;
	float spinAngle_BBOX = 0;

	QString path;

	/// <summary> QVTK Widget </summary>
	QVTKWidget *qv;

	/// <summary> Color Dialog </summary>
	QColorDialog* colorDialog;

	
	vtkSmartPointer<vtkRenderWindow> renderWindow;

	/// <summary> VTK renderer </summary>
	vtkSmartPointer<vtkRenderer> renderer;

	/// <summary> Interactor style </summary>
	vtkSmartPointer<MyInteractorStyle> interactorstyle;

	/// <summary> Vector of CustomMesh objects </summary>
	vector<shared_ptr<CustomMesh> > meshes;

	/// <summary> Vector of Element objects </summary>
	vector<shared_ptr<MyElem> > myelems;

	/// <summary> Temporary area for placement of parent meshes </summary>
	vector<shared_ptr<CustomMesh> > parentMeshes;

	/// <summary> Vector of SelectedMeshes objects (weak pointers - no ownership) </summary>
	vector<weak_ptr<CustomMesh> > selectedMeshes;

	// tool tip element
	weak_ptr<MyElem> toolTip;

	// Turn on/off tool tip viewer 
	bool toolTipOn = false;

	bool widgetSelectMode = false;

	vtkSmartPointer<MySuperquadricSource> superquad;

	// Custom timers
	QTimer* timer_explode;
	bool explode_out = true;

	QTimer* timer_highlight;
	clock_t timer_highlight_start;

	vtkSmartPointer<vtkTexture> texture;
	bool texturedbackground = false;		// Will be toggled on first run

	QString style_button_default = R"(
	border-radius: 4px;
	color: #ffffff;
	padding: 5px;
	border: none;
	}
	QPushButton:hover {
	background: #82766A;
	}
	QPushButton:pressed {	
	background: #474037;
	}
	)";

#pragma endregion

	friend class MyInteractorStyle;

protected:
	Ui::aperioClass ui;

private:

	// CurrentType
	ToolType toolTip_currentType = CUTTER;

	/// <summary> Label located inside the statusbar </summary>
	QLabel* status_label;

	/// Frame rate (frames per second)
	float fps;

	/// <summary> Boolean to toggle pausing VTK rendering </summary>
	bool pause;

	/////////////////////////////////////// PUBLIC SLOTS //////////////////////////////////////////////////////////////////
	public slots:

	// ------------------------------------------------------------------------
	/// <summary> Slot called when mouse is hovering over list item
	/// </summary>
	void slot_listitementered(QListWidgetItem * item)
	{
	}

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Ribbons button clicked
	/// </summary>
	void slot_btnRibbons();	

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Ring slider button clicked
	/// </summary>
	void slot_btnRing();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Rod slider button clicked
	/// </summary>
	void slot_btnRod();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Restore button clicked
	/// </summary>
	void slot_btnRestore();
	void slot_btnRestoreInternal(shared_ptr<CustomMesh> selectedMesh);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Magnifying glass button clicked
	/// </summary>
	void slot_btnGlass()
	{
		previewer = !previewer;

		QPixmap pixmap;
		if (previewer)
			pixmap = QPixmap(":/aperio/glass2.png");
		else
			pixmap = QPixmap(":/aperio/glass.png");
		ui.btnGlass->setIcon(QIcon(pixmap));
	}

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Invert Path clicked
	/// </summary>
	void aperio::slot_btnInvert();

		// ------------------------------------------------------------------------
	/// <summary> Slot called to toggle background
	/// </summary>
	void slot_btnBackground();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Pick Up button clicked
	/// </summary>
	void slot_btnPickUp();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Plant button clicked
	/// </summary>
	void slot_btnPlant();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Cookie Cutter button clicked
	/// </summary>
	void slot_btnCookie();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when ACTUAL cut button clicked
	/// </summary>
	void slot_btnCut();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Hinge button clicked
	/// </summary>
	void slot_btnHinge();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Slice button clicked
	/// </summary>
	void slot_btnKnife();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Show/Hide button clicked
	/// </summary>
	void slot_btnHide();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Front Ribbons checkbox checked
	/// </summary>
	void slot_chkFrontRibbons(bool checked);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Ribbon Width Slider changed
	/// </summary>
	void slot_ribbonwidthSlider(int value);
	
	// ------------------------------------------------------------------------
	/// <summary> Slot called when Ribbon Frequency Slider changed
	/// </summary>
	void slot_ribbonfreqSlider(int value);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Ribbon Tilt Slider changed
	/// </summary>
	void slot_ribbontiltSlider(int value);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Phi Slider changed
	/// </summary>
	void slot_phiSlider(int value);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Taper Slider changed
	/// </summary>
	void slot_taperSlider(int value);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Theta Slider changed
	/// </summary>
	void slot_thetaSlider(int value);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Thickness Slider changed
	/// </summary>
	void slot_thicknessSlider(int value);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Toroidal checkbox checked
	/// </summary>
	void slot_chkToroid(bool checked);

	// ------------------------------------------------------------------------
	/// <summary> Slot called depth peeling checkbox is togggled
	/// </summary>
	void slot_chkDepthPeel(bool checked);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Snap to BBOX checkbox is togggled
	/// </summary>
	void slot_chkSnap(bool checked);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Snap to BBOX REAL-TIME checkbox is togggled
	/// </summary>
	void slot_chkSnapReal(bool checked);

	// ------------------------------------------------------------------------
	/// <summary> Slot called cap checkbox is togggled
	/// </summary>
	void slot_chkCap(bool checked);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when list item clicked (i is the index of the clicked item)
	/// </summary>
	/// <param name="item">Clicked item </param>
	void slot_listitemclicked(QListWidgetItem *item);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when list item right-clicked (pos is position of clicked)
	/// </summary>
	/// <param name="pos">Clicked item point </param>
	void slot_listitemrightclicked(const QPoint & pos);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when list item doubleclicked (i is the index of the clicked item)
	/// </summary>
	/// <param name="item">Clicked item </param>
	void slot_listitemdoubleclicked(QListWidgetItem *item);

	// ------------------------------------------------------------------------
	/// <summary> Slot is a timer that runs once every click (to highlight item temporarily)
	/// </summary>
	void slot_timer_highlight();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when hinge slider's value changed
	/// </summary>
	/// <param name="i">value changed</param>
	void slot_hingeSlider(int value);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when ring exploder's slider value changed
	/// </summary>
	/// <param name="i">value changed</param>
	void slot_ringSlider(int value);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when rod exploder's slider value changed
	/// </summary>
	/// <param name="i">value changed</param>
	void slot_rodSlider(int value);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when Hinge Amount changed in QLineEdit (textbox)
	/// </summary>
	void slot_txtHingeAmount(const QString &string);

	// ------------------------------------------------------------------------
	/// <summary> Slot called when the Diffuse Translucency (Light) button clicked
	/// </summary>
	void slot_buttonclicked()
	{
		difftrans = !difftrans;
		ui.btnLight->setText((difftrans ? QString("On") : QString("Off")));

		QPixmap pixmap;
		if (difftrans)
			pixmap = QPixmap(":/aperio/flashlight2.png");
		else
			pixmap = QPixmap(":/aperio/flashlight.png");
		ui.btnLight->setIcon(QIcon(pixmap));

		print_statusbar("Light toggled!");
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called when the Color button clicked
	/// </summary>
	void slot_colorclicked()
	{
		QColor color;
		colorDialog->setVisible(true);
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called when the Color is changed
	/// </summary>
	void slot_colorchanged(const QColor & color)
	{
		if (selectedMeshes.size() == 0)
			return;

		auto selectedMesh = selectedMeshes.back().lock();

		if (selectedMesh != nullptr)
		{
			float r = color.red() / 255.0;
			float g = color.green() / 255.0;
			float b = color.blue() / 255.0;

			selectedMesh->actor->GetProperty()->SetDiffuseColor(r, g, b);
			selectedMesh->actor->GetProperty()->SetAmbientColor(r, g, b);

			vtkColor3f mycol(r, g, b);
			selectedMesh->color = mycol;
		}
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called when Help->About menu item clicked
	/// </summary>
	void slot_about()
	{
		QMessageBox messageBox(this);

		messageBox.setIconPixmap(QPixmap("about.png"));

		QChar co(169);

		messageBox.setWindowTitle("About Aperio");
		messageBox.setText("Aperio");
		messageBox.setInformativeText("1.0.0.4 (Released 12-12-2014) \n\nCopyright " + QString(co) + " 2011-2014 \n\nDavid Tran & Tim McInerney, \nRyerson University\n");
		messageBox.setWindowOpacity(.85);
		messageBox.setStyleSheet("background: rgba(0, 0, 0, 255); color: white; selection-color: black;");

		QPushButton *okButton = messageBox.addButton(tr("Ok"), QMessageBox::ActionRole);

		okButton->setStyleSheet(this->styleSheet());
		messageBox.exec();
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called some milliseconds after clicking top-level menu (File, Help, etc.) to fade opacity
	/// </summary>
	void slot_menuclick2()
	{
		float menu_opacity = 0.8f;
		ui.menuHelp->setWindowOpacity(menu_opacity);
		ui.menuFile->setWindowOpacity(menu_opacity);
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called upon clicking a top-level menu (File, Help, etc.)
	/// </summary>
	void slot_menuclick()
	{
		// Wait for menu fade-in animation to complete before setting opacity
		QTimer::singleShot(200, this, SLOT(slot_menuclick2()));
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called as frequently as possible - instantaneous timer
	/// </summary>
	void slot_timeout_instant()
	{
		if (!pause) qv->update();
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called according to FPS speed (updates qv widget)
	/// </summary>
	void slot_timeout_fps();

	// ------------------------------------------------------------------------
	/// <summary> Slot called less frequently (few times a second)
	/// </summary>
	void slot_timeout_delay()
	{
		// Update Shaders Periodically (so we can make real-time changes to shaders and reload) [Debugging Purposes!]
		// Disable if graphics card heats up
		//Utility::updateShader(pgm, "shader_water.vert", "shader.frag");
		Utility::updateShader(preP->Program1, "shader_water.vert", "shader0.frag");
		Utility::updateShader(mainP->Program1, "shader_water.vert", "shader.frag");
	}

	// ------------------------------------------------------------------------
	/// <summary> Slot called as a thread to perform explosion (fps rate)
	/// </summary>
	//void slot_timer_explode();

	// ------------------------------------------------------------------------
	/// <summary> Slot called when File->Open clicked
	/// </summary>
	void slot_open()
	{
		pause = true;

		if (path.isEmpty())
			path = QDir::currentPath();

		QString selectedFilter;
		QFileDialog::Options options;

		QString fileName = QFileDialog::getOpenFileName(this,
			"Select a file.", QString(path),
			"OBJ Files (*.obj);;All Files (*)",
			&selectedFilter,
			options);

		pause = false;

		if (!fileName.isEmpty())
		{
			path = QFileInfo(fileName).path(); // store path for next time

			print_statusbar("Loading file...please be patient!");
			readFile(fileName.toLocal8Bit().data());
			print_statusbar("File loaded");
		}
		else
			print_statusbar("No file specified.");
	}

	// ------------------------------------------------------------------------
	/// <summary> Slot called when File->Apppend clicked
	/// </summary>
	void slot_append()
	{
		pause = true;

		if (path.isEmpty())
			path = QDir::currentPath();

		QString selectedFilter;
		QFileDialog::Options options;

		QStringList filenames = QFileDialog::getOpenFileNames(this, 
			"Select file(s)", QString(path), 
			"OBJ Files (*.obj);;All Files (*)", 
			&selectedFilter, 
			options);

		pause = false;


		for (QString &fileName : filenames)
		{
			if (!fileName.isEmpty())
			{
				path = QFileInfo(fileName).path(); // store path for next time

				print_statusbar("Appending file...please be patient!");
				appendFile(fileName.toLocal8Bit().data());
				print_statusbar("File appended");
			}
			else
				print_statusbar("No file specified.");
		}
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called when File->Exit clicked
	/// </summary>
	void slot_exit()
	{
		QMessageBox mb(this);
		mb.setStyleSheet("color: white; background: black; selection-color: black;");
		mb.setWindowOpacity(0.9);
		mb.setWindowTitle(this->windowTitle());
		mb.setText("Are you sure you want to quit?");
		mb.setIcon(QMessageBox::Warning);

		QPushButton *yesButton = mb.addButton(tr("Yes"), QMessageBox::ActionRole);
		QPushButton *noButton = mb.addButton(tr("No"), QMessageBox::ActionRole);
		//noButton->setFocus();

		yesButton->setStyleSheet(this->styleSheet());
		noButton->setStyleSheet(this->styleSheet());

		mb.exec();
		if (mb.clickedButton() == yesButton)
			QApplication::quit();
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called when File->New Window menu item clicked
	/// </summary>
	void slot_preview()
	{
		resizeInternal(this->size(), true);
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called when fullscreen menu item clicked
	/// </summary>
	void slot_fullScreen()
	{
		if (this->isFullScreen())
			this->showNormal();
		else
			this->showFullScreen();
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called when opacity slider value changed
	/// </summary>
	/// <param name="i">new opacity value</param>
	void slot_opacitySlider(int i)
	{
		if (selectedMeshes.size() == 0)
			return;

		//for (auto &selectedMesh_wk : selectedMeshes)
		//{
			//auto selectedMesh = selectedMesh_wk.lock();
			auto selectedMesh = selectedMeshes.back().lock();

			// opacity is perceived opacity, i / 100.0f is actual opacity;
			float actualopacity = i / 100.0f;
			float opacity;

			opacity = actualopacity * 0.5f; //0.4f
			if (i >= 100)
				opacity = 1;

			Utility::setMeshOpacitySeparate(this, selectedMesh, actualopacity, opacity);

				// Update list check boxes
				//auto item = getListItemByName(selectedMesh->name);

				/*if (opacity == 0)
				item->setCheckState(Qt::Unchecked);
				else
				item->setCheckState(Qt::Checked);
				*/
		//}
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called when shininess slider value changed
	/// </summary>
	/// <param name="i">new shininess value</param>
	void slot_shininessSlider(int i)
	{
		shininess = i;
	}
	// ------------------------------------------------------------------------
	/// <summary> Slot called when darkness slider value changed
	/// </summary>
	/// <param name="i">new darkness value</param>
	void slot_darknessSlider(int i)
	{
		darkness = (i + 128.0f) / 128.0f;
	}
	///-----------------------------------------------------------------------------------------------
	/// <summary> Slot called after the window is fully loaded (contains all initialization code)
	/// </summary>
	void slot_afterShowWindow();

	////////////////////////////////////////////// END SLOTS //////////////////////////////////////////////////////////

	// Public Methods ----------------------------------------------------------------------------------------------
public:

	/// <summary> Make composite transform matrix (translate, rotate, scale) from elem's points, normals and scale
	/// </summary>
	vtkSmartPointer<vtkTransform> makeCompositeTransform(MyElem &elem,
		bool customScale = false,
		float customScaleX = 0,
		float customScaleY = 0,
		float customScaleZ = 0);

	/*vtkSmartPointer<vtkTransform> makeCompositeTransformFromSinglePoint(MyElem &elem,
		bool customScale = false,
		float customScaleX = 0,
		float customScaleY = 0,
		float customScaleZ = 0);*/


	vtkSmartPointer<vtkTransform> makeCompositeTransformFromSinglePoint(MyElem &elem, 
	shared_ptr<CustomMesh> selected = nullptr,
	bool customScale = false,
	float customScaleX = 0,
	float customScaleY = 0,
	float customScaleZ = 0);

	
	void SetMatrix4x4(double *matrix4x4, vtkVector3f v0, vtkVector3f v1, vtkVector3f v2);
	void SetRotationMatrix4x4(double *matrix4x4, float angle, vtkVector3f axis);
	
	

	//--------------------------------------------------------------------------
	/// <summary> Obtain CustomMesh by name
	/// </summary>
	/// <param name="name">Name of object (string) </param>
	weak_ptr<CustomMesh> getMeshByName(string name)
	{
		auto it = find_if(meshes.begin(), meshes.end(), [=](shared_ptr<CustomMesh> &c) 
		{ return c->name.compare(name) == 0; });

		if (it != meshes.end())
			return *it;
		else
			return weak_ptr<CustomMesh>();
	}
	/// <summary> Obtain CustomMesh by vtkActor smartpointer
	/// </summary>
	/// <param name="name">vtkActor SmartPointer to compare with all CustomMeshes' actors</param>
	weak_ptr<CustomMesh> getMeshByActor(vtkSmartPointer<vtkActor> actor)
	{
		auto it = find_if(meshes.begin(), meshes.end(), [=](shared_ptr<CustomMesh> &c)
		{ return c->actor.GetPointer() == actor.GetPointer(); });

		if (it != meshes.end())
			return *it;
		else
			return weak_ptr<CustomMesh>();
	}
	/// <summary> Obtain CustomMesh by vtkActor raw pointer
	/// </summary>
	/// <param name="name">vtkActor raw pointer to compare with all CustomMeshes' actors</param>
	weak_ptr<CustomMesh> getMeshByActorRaw(vtkActor* actor)
	{
		auto it = find_if(meshes.begin(), meshes.end(), [=](shared_ptr<CustomMesh> &c)
		{ return c->actor.GetPointer() == actor; });

		if (it != meshes.end())
			return *it;
		else
			return weak_ptr<CustomMesh>();
	}
	
	/// <summary> Get CustomMesh's iterator
	/// </summary>
	/// <param name="name">weak_ptr to CustomMesh </param>
	vector<shared_ptr<CustomMesh> >::iterator getMeshIterator(weak_ptr<CustomMesh> it)
	{
		auto result = find_if(meshes.begin(), meshes.end(), [=](shared_ptr<CustomMesh> &c) { return c == it.lock(); });
		return result;
	}

	/// <summary> Get Elem's iterator
	/// </summary>
	/// <param name="name">weak_ptr to MyElem </param>
	vector<shared_ptr<MyElem> >::iterator getElemIterator(weak_ptr<MyElem> it)
	{
		auto result = find_if(myelems.begin(), myelems.end(), [=](shared_ptr<MyElem> &c) { return c == it.lock(); });
		return result;
	}

	/// <summary> Create a superquad element
	/// </summary>
	/// 
	void createIncisionElement();
	void createtoolTipElement();


	/// <summary> Obtain Widget/Element by vtkActor raw pointer
	/// </summary>
	/// <param name="name">vtkActor raw pointer to compare with all myelems' actors</param>
	weak_ptr<MyElem> getElemByActorRaw(vtkActor* actor)
	{
		auto it = find_if(myelems.begin(), myelems.end(), [=](shared_ptr<MyElem> &e)
		{ return e->actor.GetPointer() == actor; });

		if (it != myelems.end())
			return *it;
		else
			return weak_ptr<MyElem>();
	}
	/// <summary> Obtain ListItem and QListWidget by name
	/// </summary>
	/// <param name="name">Name of item (string) </param>
	QListWidgetItem* getListItemByName(string name)
	{
		for (int i = 0; i < ui.listWidget->count(); i++) {
			string itemString = ui.listWidget->item(i)->text().toStdString();

			if (itemString.compare(name) == 0)	// If list item text == selected item text
			{
				return ui.listWidget->item(i);
			}
		}
		return nullptr;
	}
	/// <summary> Set list item as selected
	/// </summary>
	/// <param name="item">item (QListWidgetItem) </param>
	void setListItemSelected(QListWidgetItem *item)
	{
		ui.listWidget->clearSelection();
		item->setSelected(true);
		
		ui.listWidget->scrollToItem(item);
	}

	/// <summary> Add to list a new item with name
	/// </summary>
	/// <param name="name">Name of item (string) </param>
	void addToList(string name)
	{
		QListWidgetItem* item = new QListWidgetItem(name.c_str(), ui.listWidget);

		item->setCheckState(Qt::Unchecked);
		item->setFlags(item->flags() & ~Qt::ItemIsUserCheckable);
		ui.listWidget->addItem(item);
	}

	/// <summary> Remove from list
	/// </summary>
	/// <param name="name">Name of item (string) </param>
	void RemoveFromList(string name)
	{
		auto listitem = getListItemByName(name);

		if (listitem != nullptr)
		{
			int index = ui.listWidget->row(listitem);
			ui.listWidget->takeItem(index);
		}
	}

	/// <summary> Replace old actor by new actor in Renderer
	/// </summary>
	/// <param name="oldActor">Reference to old actor </param>
	/// <param name="newActor">Reference to new actor </param>
	void replaceActor(vtkSmartPointer<vtkActor> oldActor, vtkSmartPointer<vtkActor> newActor)
	{
		// Now replace mesh too
		vtkPropCollection* actors = renderer->GetViewProps();
		actors->InitTraversal();

		vtkProp* current_actor = nullptr;
		int i = -1;
		while ((current_actor = actors->GetNextProp()) != nullptr)
		{
			i++;
			if (vtkActor::SafeDownCast(current_actor) == oldActor)	// Find selectedMesh's old actor to replace (Found)
			{
				renderer->GetViewProps()->ReplaceItem(i, newActor);
				break;
			}
		}
	}
	/// <summary> Event called when window resized (resizes qvtkwidget)
	/// </summary>
	/// <param name="event">Event object (Qt-based)</param>
	virtual void resizeEvent(QResizeEvent *) override;

	/// <summary> Event called when mouse moves over window
	/// </summary>
	/// <param name="">Event object (Qt-based)</param>
	virtual void mouseMoveEvent(QMouseEvent *) override;

	// Custom methods
	void resizeInternal(const QSize &newWindowSize, bool using_preview);
	void update_orig_size();

	// ------------------------------------------------------------------------
	/// <summary> Reads an .obj file and loads into meshes vector
	/// </summary>
	/// <param name="filename">filename.</param>
	void readFile(string filename);

	// ------------------------------------------------------------------------
	/// <summary> Reads an .obj file and loads into meshes vector
	/// </summary>
	/// <param name="filename">filename.</param>
	void appendFile(string filename);

	// ------------------------------------------------------------------------------------------
	/// <summary> Reset clipping plane (call this after any resetCamera calls, flyTo, etc.)
	/// </summary>
	void resetClippingPlane();

	// ------------------------------------------------------------------------
	/// <summary> Changes label in status bar to a new message
	/// </summary>
	/// <param name="text">The message.</param>
	void print_statusbar(string text)
	{
		status_label->setText(text.c_str());
		QApplication::processEvents();
	}
	// ------------------------------------------------------------------------
	/// <summary> Updates slider opacity value; called when list item clicked
	/// </summary>
	void updateOpacitySliderAndList();

	// ------------------------------------------------------------------------
	/// <summary> Slice element into two
	/// </summary>
	void slice();
	string sliceInternal(weak_ptr<CustomMesh> selectedMesh_wk);	// Returns name of sliced elem in list

	// ------------------------------------------------------------------------
	/// <summary> Updates toroidal or not for the tooltip
	/// </summary>
	void updateToroidal();

	Ui::aperioClass& getUI()
	{
		return ui;
	}

	void removeParentMesh(weak_ptr<CustomMesh> it);	// weak_ptr to item (can also be shared_ptr)

	void addSelectedMesh(weak_ptr<CustomMesh> it);
	void removeSelectedMesh(weak_ptr<CustomMesh> it);	// weak_ptr to item (can also be shared_ptr)
	void removeSelectedMesh(int index);					// item index
	void clearSelectedMeshes();

	vector<weak_ptr<CustomMesh> >::iterator getSelectedMeshIterator(weak_ptr<CustomMesh> it);

	void updateSelectedMeshes();

	// Parent Mesh Transfer methods (Transfer mesh from and to parent meshes vector)
	void transferToParentMeshes(shared_ptr<CustomMesh> mesh);
	void transferToMeshes(shared_ptr<CustomMesh> parent);

	void loadMatCapTexture(string filename);

	void addElem(weak_ptr<MyElem> it);
	void removeElem(weak_ptr<MyElem> it);	// weak_ptr to item (can also be shared_ptr)
	void clearElems();

	// Forward key events from Aperio to QVTKWidget
	virtual void keyPressEvent(QKeyEvent *) override;

	static const int NO_LEAFING = -1;
	static float RING_PERCENT;
	static double DEFAULT_TAPER;
	static double DEFAULT_RODSIZE;

	void explodeSlide(int value, int leafvalue = NO_LEAFING);
	void explodeSlideInternal(int value, weak_ptr<CustomMesh> selectedMesh_wk, int leafvalue = NO_LEAFING, int index = -1, int size = -1);

	void setCursor(bool release);

	void setCurrentToolTipType(ToolType type)
	{
		toolTip_currentType = type;
		updateButtons(type);
	}
	ToolType getCurrentToolTipType()
	{
		return toolTip_currentType;
	}
	void updateButtons(ToolType type);

	void createPath();
	void createPathInternal(weak_ptr<CustomMesh> selectedMesh_wk);

	void setWidgetSelectMode(bool mode);
	void makeOutline(weak_ptr<MyElem> elem_wk, bool update = false);
	void removeOutline(weak_ptr<MyElem> elem_wk);

	void showSelected();
	void makeToolTipIfDoesntExist();
};



#endif // APERIO_H
