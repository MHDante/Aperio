varying vec3 vertex_light_position;
varying vec3 vertex_normal;


void main()
{
  vertex_normal = normalize(gl_NormalMatrix * gl_Normal);
    // Calculate the light position for this vertex
    vertex_light_position = normalize(gl_LightSource[0].position.xyz);
	
	gl_FrontColor = gl_Color;
	
	//gl_TexCoord[0] = gl_MultiTexCoord0;
	gl_Position = ftransform();
}
-----------------
<?xml version="1.0" encoding="UTF-8"?>
<Material name="Twisted">


  <Shader scope="Vertex" name="GLSLTwisted" location="Twisted.glsl" 
	language="GLSL" entry="main">
  </Shader>
  <Shader scope="Fragment" name="GLSLTwisted" location="TwistedFrag.glsl" 
	language="GLSL" entry="main">
	 <ApplicationUniform name="mouse" > </ApplicationUniform> 
	 <ApplicationUniform name="translucency" > </ApplicationUniform> 
	 <ApplicationUniform name="mouseSize" > </ApplicationUniform> 
	 <ApplicationUniform name="peerInside" > </ApplicationUniform> 
	 <ApplicationUniform name="selected" > </ApplicationUniform> 
	 <ApplicationUniform name="toon" > </ApplicationUniform> 
	</Shader>

</Material>
------------
varying vec3 vertex_light_position;
varying vec3 vertex_normal;

// texture
// radius for valley detection
const int radius = 1;
// rendered image width
const int renderwidth = 1;
 
float intensity(in vec4 color)
{
	return sqrt((color.x*color.x)+(color.y*color.y)+(color.z*color.z));
}
 
vec3 simple_edge_detection(in float step, in vec4 center)
{
	// let's learn more about our center pixel
	float center_intensity = intensity(gl_Color); //intensity(texture2D(color, center));
	// counters we need
	int darker_count = 0;
	float max_intensity = center_intensity;
	// let's look at our neighbouring points
	for(int i = -radius; i <= radius; i++)
	{
		for(int j = -radius; j<= radius; j++)
		{
			vec2 current_location = center + vec2(i*step, j*step);
			float current_intensity = intensity(gl_Color);//intensity(texture2D(color,current_location));
			if(current_intensity < center_intensity) 			{ 				darker_count++; 			} 			if(current_intensity > max_intensity)
			{
				max_intensity = current_intensity;
			}
		}
	}
	// do we have a valley pixel?
	if((max_intensity - center_intensity) > 0.01*radius)
	{
		if(darker_count/(radius*radius) < (1-(1/radius)))
		{
			return vec3(0.0,0.0,0.0); // yep, it's a valley pixel.
		}
	}
	return vec3(1.0,1.0,1.0); // no, it's not.
 
}
 
void main(void)
{
    // Set the diffuse value (darkness). This is done with a dot product between the normal and the light
    // and the maths behind it is explained in the maths section of the site.
    float diffuse_value = max(dot(vertex_normal, vertex_light_position), 0.0);
	
	vec4 myColor = vec4(vec3(1,0,0) * diffuse_value, 1.0);
	
	 float step = 1.0/renderwidth;
	 vec2 center_color = gl_TexCoord[0].st;
	 //gl_FragColor.xyz = simple_edge_detection(step,center_color);
	 //gl_FragColor.xyz = simple_edge_detection(step,gl_Color);
     gl_FragColor.a = 1.0;
	 gl_FragColor.xyz = simple_edge_detection(step,myColor);
	 
	 //if (myColor.r <= 0.4 && myColor.g <= 0.4 && myColor.b <= 0.4)
//		gl_FragColor = vec4(0, 0, 0, 1);

}